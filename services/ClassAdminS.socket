#!/usr/bin/python3
import os,sys,socket,signal,platform,requests,urllib3,signal,time,psutil,ssl,multiprocessing
from sources.Client import Client
from sources.handlerSignals import HandlerSignals
from sources.utils import Environment, getIpAddress, logFile,systemProcess
from sources.notification import Notify
try:
    urllib3.disable_warnings()
    try:
        PORT = requests.get("https://localhost/api/server/port", headers={
            "password": ",UPsz)ZfF~ZOh^:YH)o[4P<sF7$jS(",
            "otp": ",UPsz)ZfF~ZOh^:YH)o[4P<sF7$jS("
        }, cert=(f"{Environment.SSL('crt')}", f"{Environment.SSL('key')}"))
        PORT = PORT.json()["result"][0]["port"]

        CLIENTS = requests.get("https://localhost/api/server/clients", headers={
            "password": ",UPsz)ZfF~ZOh^:YH)o[4P<sF7$jS(",
            "otp": ",UPsz)ZfF~ZOh^:YH)o[4P<sF7$jS("
        }, cert=(f"{Environment.SSL('crt')}", f"{Environment.SSL('key')}"))
        CLIENTS = CLIENTS.json()["result"][0]["clients"]
    except:
        raise ConnectionError
    print(os.getpid())
    HandlerSignals()

    # This creates a ssl tunnel with the ClassAdmin's certificate and private key
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(Environment.SSL("crt"),Environment.SSL("key"))

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(("",PORT))
    sock.listen(CLIENTS)
    Notify("showinfo",logFile().message(f"running ClassAdmin server, listen {CLIENTS} clients by port {PORT}...",True,"INFO"))
    sockSSL = context.wrap_socket(sock,server_side=True)
    while sockSSL:
        connection, address = sockSSL.accept()
        print(address)
        multiprocessing.Process(target=Client,name="client",args=(connection,address)).start()
        time.sleep(1)

#When the service shutdown successfully
except (KeyboardInterrupt,SystemExit) as err:
        Notify("showinfo",logFile().message("shutdown ClassAdmin server...", True, "INFO"))

#When the service has a error unexpected
except BaseException as err:
    type, object, traceback = sys.exc_info()
    file = traceback.tb_frame.f_code.co_filename
    line = traceback.tb_lineno
    if type(err)==ConnectionError:
        Notify("showerror", logFile().message(f"Connection at database failed in {file}:{line}", True, "ERROR"))
    else:
        Notify("showerror",logFile().message(f"{err} in {file}:{line}",True,"ERROR"))

finally:
    try:
        sock.close()
    except:
        None