#!/usr/bin/python3
import sys, socket, urllib3, time, ssl, os, multiprocessing, threading
from sources.pipeServer import PipeServer
from sources.eventsClient import EventsClient
from sources.handlerSignals import HandlerSignals
from sources.utils import Environment, logFile, Notify
from sources.Requests import Requests
class SocketClient:
    def __init__(self, **kwargs):
        try:
            self.__comunicationServer()
            self.args = kwargs["args"]
            urllib3.disable_warnings()
            self.__checkParams()
            self.__globalsVars()
            self.__SSLTunel()
            self.__createSocket()
            self.__handlerServer()
            self.__body()

        # When the service shutdown successfully or one socket error
        except (KeyboardInterrupt, SystemExit, socket.error) as err:
            # This I use it for the TooManyClients and sameUser messages.
            try:
                if err.args[0] == -5000:
                    Notify("Error", logFile().message(err.args[1], err.args[2], "ERROR"))
            except:
                None

        # When the service has a error unexpected
        except BaseException as err:
            if err.args[0] == -5000:
                Notify("Error", logFile().message(err.args[1], err.args[2], "ERROR"))
            else:
                type, object, traceback = sys.exc_info()
                file = traceback.tb_frame.f_code.co_filename
                line = traceback.tb_lineno
                if type(err) == ConnectionError:
                    Notify("Error", logFile().message(f"Connection at database failed in {file}:{line}", True, "ERROR"))
                else:
                    Notify("Error", logFile().message(f"{err} in {file}:{line}", True, "ERROR"))

        finally:
            try:
                self.pipeServer.terminate()
                self.eventPipe.set()
                self.sockSSL.send(b"sig.SystemExit")
                self.sockSSL.close()
            except:
                None
            Notify("Turnning off ClassAdmin", logFile().message("Good bye :). What you have a good day", True, "INFO"))
            exit()

    # miniserver for to allow from Django comunicate and send data.
    def __comunicationServer(self):
        self.eventPipe = multiprocessing.Event()
        self.pipeServer = multiprocessing.Process(target=PipeServer, name="pipeClient", args=(self.eventPipe,))
        threading.Thread(target=PipeServer.close, name="closePipeClient",args=(self.pipeServer, self.eventPipe,)).start()
        self.pipeServer.start()

    def __body(self):
        Notify("Connected sucessfully", logFile().message(f"ClassAdmin connected", True, "INFO"))
        self.sockSSL.send(f"HelloServer: {self.NICK}".encode("utf-8"))
        while True:
            data = self.sockSSL.recv(1024)
            text = data.decode("utf-8")
            logFile().message(text)
            if text.startswith("sig."):
                exec(f"raise {text.split('.', 1)[1]}")
            elif text.startswith("act."):
                args = text.split(".")[2:]
                text = text.split('.')[1]
                logFile().message(f"{text}")
                EventsClient(f"{text}").run(args)
            elif data:
                Notify("Message", logFile().message(text, True, "INFO"))
            elif len(data) == 0:
                raise SystemExit

    def __handlerServer(self):
        Notify("Start ClassAdmin", logFile().message(f"Good days :D. Service ClassAdmin started.", True, "INFO"))
        while True:
            try:
                PORT = int(
                    Requests("services", "GET", "https://classadmin.server/api/servers").run().json()["result"][0][
                        "port"])
                # connection at server (without specified ip address), so if the server changes the ip address,
                # the client will can connect.
                self.sockSSL.connect(("classadmin.server", PORT))
                break
            except BaseException as err:
                try:
                    if err.args[0] != 10061 and sys.platform.system().upper() == "WINDOWS":
                        os.system(f"taskkill /PID {multiprocessing.current_process().pid} /F")
                    else:
                        pass
                except:
                    pass
            time.sleep(.5)

    def __createSocket(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sockSSL = self.context.wrap_socket(sock, server_hostname="classadmin.server")
        HandlerSignals(self.sockSSL)

    # This creates a ssl tunnel with the ClassAdmin's certificate and private key
    def __SSLTunel(self):
        self.context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
        self.context.load_verify_locations(Environment.CA)

    def __globalsVars(self):
        self.NICK = f"{self.args[1]}"

    def __checkParams(self):
        if len(self.args) == 1 or len(self.args) > 2:
            raise BaseException(-5000, f"The script needs 1 argument\\nClassAdmin.socket <nick>", True)


if __name__ == "__main__":
    SocketClient(args=sys.argv)